# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Pipeline CI/CD â€” Toys Academy
#
# CE QUE Ã‡A FAIT :
#   â€¢ Sur chaque push (toutes branches) ou pull_request :
#       â†’ Construit les 3 images Docker pour vÃ©rifier que tout compile âœ…
#   â€¢ Sur un push vers la branche "main" uniquement :
#       â†’ Construit ET publie les images sur GitHub Container Registry (ghcr.io)
#         afin qu'elles soient disponibles pour le dÃ©ploiement sur le serveur
#
# IMAGES PUBLIÃ‰ES (ghcr.io) :
#   ghcr.io/<owner>/ccd_toys-academy/optimisation:latest  (+ tag SHA du commit)
#   ghcr.io/<owner>/ccd_toys-academy/backend:latest       (+ tag SHA du commit)
#   ghcr.io/<owner>/ccd_toys-academy/frontend:latest      (+ tag SHA du commit)
#
# AUCUNE MODIFICATION du code des autres membres â€” ce fichier lit le code
# en lecture seule pour builder les images Docker existantes.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

name: CI/CD â€“ Build & Publish Docker images

on:
  push:
    branches:
      - '**'          # Toutes les branches (main, develop, feature/*, etc.)
  pull_request:       # Toutes les Pull Requests

# EmpÃªche deux runs en parallÃ¨le sur la mÃªme branche (Ã©vite les conflits)
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  # github.repository â†’ "dodoschouv/ccd_toys-academy"
  # On prÃ©fixe chaque image avec le registry et le repo
  IMAGE_BASE: ghcr.io/${{ github.repository }}

jobs:
  build-and-push:
    name: Build & Push (${{ matrix.service }})
    runs-on: ubuntu-latest

    # Permissions nÃ©cessaires :
    #   contents: read  â†’ cloner le dÃ©pÃ´t
    #   packages: write â†’ pusher les images sur ghcr.io (uniquement sur main)
    permissions:
      contents: read
      packages: write

    # On lance le build pour les 3 services en parallÃ¨le grÃ¢ce Ã  la matrix
    strategy:
      fail-fast: false   # Si un service Ã©choue, continue de builder les autres
      matrix:
        include:
          - service: optimisation
            context: ./optimisation
            dockerfile: ./optimisation/Dockerfile

          - service: backend
            context: ./web/backend
            dockerfile: ./web/backend/Dockerfile

          - service: frontend
            context: ./web/frontend
            dockerfile: ./web/frontend/Dockerfile

    steps:
      # 1) RÃ©cupÃ©rer le code du dÃ©pÃ´t
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4

      # 2) Activer Docker BuildKit (builds multi-stage plus rapides + cache)
      - name: ğŸ³ Configurer Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 3) Se connecter Ã  ghcr.io â€” UNIQUEMENT si on est sur main
      #    GITHUB_TOKEN est automatique, aucun secret Ã  configurer dans le repo
      - name: ğŸ” Login sur GitHub Container Registry
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 4) Builder (+ pusher si on est sur main) l'image du service courant
      #
      #    Tags gÃ©nÃ©rÃ©s :
      #      :latest     â†’ toujours la derniÃ¨re version de main
      #      :sha-XXXXXX â†’ version immutable liÃ©e Ã  un commit prÃ©cis
      #
      #    cache-from/cache-to â†’ GitHub Actions cache : accÃ©lÃ¨re les rebuilds
      #    (Maven ne re-tÃ©lÃ©charge pas les dÃ©pendances, npm non plus)
      - name: ğŸ”¨ Build${{ github.ref == 'refs/heads/main' && github.event_name == 'push' && ' & Push' || '' }} â€” ${{ matrix.service }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: ${{ github.ref == 'refs/heads/main' && github.event_name == 'push' }}
          tags: |
            ${{ env.IMAGE_BASE }}/${{ matrix.service }}:latest
            ${{ env.IMAGE_BASE }}/${{ matrix.service }}:sha-${{ github.sha }}
          cache-from: type=gha,scope=${{ matrix.service }}
          cache-to: type=gha,scope=${{ matrix.service }},mode=max
          # MÃ©tadonnÃ©es pour tracer l'image jusqu'au commit source
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Job : deploy
  # Se dÃ©clenche UNIQUEMENT sur push main, APRÃˆS que les 3 images soient
  # buildÃ©es et publiÃ©es sur ghcr.io avec succÃ¨s.
  # Se connecte en SSH Ã  Docketu et redÃ©marre l'application.
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy:
    name: ğŸš€ Deploy sur Docketu
    runs-on: ubuntu-latest
    needs: build-and-push   # Attend que les 3 builds soient verts
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: ğŸš€ DÃ©ploiement via SSH
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd ~/ccd_toys-academy

            # RÃ©cupÃ¨re les derniÃ¨res modifications (docker-compose, etc.)
            git pull --rebase

            # TÃ©lÃ©charge les nouvelles images depuis ghcr.io
            docker compose -f docker-compose.prod.yml pull

            # RedÃ©marre les conteneurs avec les nouvelles images
            docker compose -f docker-compose.prod.yml up -d

            # Affiche l'Ã©tat final des conteneurs
            echo "=== Conteneurs en cours ==="
            docker compose -f docker-compose.prod.yml ps

